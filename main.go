package main

import (
	"errors"
	"fmt"
)

func main() {
	fmt.Println("Please see the unit test. (run it with cmd:  go test -v -run  TestMinMalwareSpread)")
}

func minMalwareSpread(graph [][]int, initial []int) map[int][]int {

	goodNodeCountByRemoveBadeNode := map[int]int{}
	for _, v := range initial {
		goodNodeCountByRemoveBadeNode[v] = findOutGoodNodeCount(removeBadNodeConnection(graph, v), initial)
	}
	return findOutBigElement(goodNodeCountByRemoveBadeNode)
}

func findOutBigElement(originalMap map[int]int) map[int][]int {
	bigest := 0
	for _, v := range originalMap {
		if v > bigest {
			bigest = v
		}
	}

	res := map[int][]int{}

	for k, v := range originalMap {
		if v == bigest {
			res[v] = append(res[v], k)
		}
	}

	return res
}

func findOutGoodNodeCount(graph [][]int, initial []int) int {

	total := 0
	connectedGoodNodeArr := []int{}

	for nodeIdx, _ := range graph {
		if isBadNode(nodeIdx, initial) {
			continue
		}

		if alreadyCount(connectedGoodNodeArr, nodeIdx) {
			continue
		}

		countByOne, connectedNodeArrByOne, err := countConnectedGoodNode(graph, nodeIdx, initial, connectedGoodNodeArr)

		if err != nil {
			fmt.Printf("nodeIdx : %v   err: %v\n", nodeIdx, err.Error())
			continue
		}

		if countByOne > 0 {
			total = total + countByOne
			connectedGoodNodeArr = append(connectedGoodNodeArr, connectedNodeArrByOne...)
		}
	}

	return total
}

// return count and  connected node array.
func countConnectedGoodNode(graph [][]int, goodNodeIdx int, badNodeArr, connectedNodeArr []int) (int, []int, error) {

	count := 0

	if len(graph) < goodNodeIdx {
		return 0, nil, errors.New("len(graph) < goodNodeIdx")
	}

	for connectedNodeIdx, connectedNodeStatus := range graph[goodNodeIdx] {
		if connectedNodeStatus == 1 && isBadNode(connectedNodeIdx, badNodeArr) {
			return 0, nil, errors.New(fmt.Sprintf("find out connected bad node idx %v by node %v", connectedNodeIdx, goodNodeIdx))
		}

		if alreadyCount(connectedNodeArr, connectedNodeIdx) {
			continue
		}
		if connectedNodeStatus == 1 {
			count = count + 1
			connectedNodeArr = append(connectedNodeArr, connectedNodeIdx)

			nextconnectedNodeCount, nextconnectedNodeArr, err := countConnectedGoodNode(graph, connectedNodeIdx, badNodeArr, connectedNodeArr)
			if err != nil {
				return 0, nil, err
			}
			count = count + nextconnectedNodeCount
			connectedNodeArr = append(connectedNodeArr, nextconnectedNodeArr...)
		}
	}
	return count, connectedNodeArr, nil
}

func alreadyCount(nodelist []int, nodeIdx int) bool {
	for _, node := range nodelist {
		if nodeIdx == node {
			return true
		}
	}
	return false
}

func isBadNode(nodeIdx int, badNodeIdxArr []int) bool {
	for _, badNode := range badNodeIdxArr {
		if nodeIdx == badNode {
			return true
		}
	}
	return false
}

func removeBadNodeConnection(graph [][]int, badIdx int) [][]int {

	res := make([][]int, 0, len(graph))
	for nodeIdx, v := range graph {
		//reset connected node value(0) of the bad node.
		if nodeIdx == badIdx {
			connectArr := make([]int, 0, len(v))
			for k, _ := range v {
				// except itself.
				if k == badIdx {
					connectArr = append(connectArr, 1)
					continue
				}
				connectArr = append(connectArr, 0)
			}
			res = append(res, connectArr)
			continue
		}

		connectArr := make([]int, 0, len(v))
		for connectIdx, connectValue := range v {
			if connectIdx == badIdx && connectValue == 1 {
				connectArr = append(connectArr, 0)
			} else {
				connectArr = append(connectArr, connectValue)
			}
		}
		res = append(res, connectArr)
	}

	return res
}
